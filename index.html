<!DOCTYPE html>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title> africa &middot; </title>

<link rel="stylesheet" type="text/css" href="./stylesheet.css">

<script src="./r_box.js"></script>

<!-- <p><a href="./processing.php"> processing </a><p> -->

<div id="mainContainer" style="display: flex; flex-direction: row;">
<div>
<div id="container"></div>
<div id="geometryNameOutputEl"></div>
</div>
<!-- 
<div id="myPauseBtn">pause</div>
-->

<div id="myFeatureList" style="border: 2px solid #247a; margin: 5px; padding: 5px; height: 700px; overflow-y: auto;"></div>
</div>

<script>


let ANIMATION;

window.addEventListener("load", function() {
  
  /*
  myPauseBtn.addEventListener("click", function() {
    window.clearInterval(ANIMATION);
  });
  */
  
  fetch("./africa.geojson?x="+Math.random())
  .then(r=>r.json())
  .then(FeatureCollection=>{
    
    //console.log(FeatureCollection);
    
    let features = FeatureCollection.features;
    
    for (let i = 0; i < features.length; i++) {
      
      addGeometryMinMax(feature_=features[i]);

      // START OF SIDEBAR
      

      if (window.innerWidth < 500) {
        myFeatureList.style.display = "none";
      }
      if (window.innerWidth > 500) {
      
        
        let div = document.createElement("div");
        div.style.cursor = "default";
        div.style.padding = "5px";
        if (i%2 == 0) {
          div.style.backgroundColor = "#2473";
        }
        myFeatureList.appendChild(div);
        div.innerHTML = features[i]["properties"]["NAME"];
        
        div.addEventListener("click", function() {
           obj = features.filter(f => f["properties"]["NAME"] === features[i]["properties"]["NAME"])[0];
           console.log(obj);
           // phase = false;
           abc(obj_=obj, phase_=false);
           geometryNameOutputEl.innerHTML = obj["properties"]["NAME"];
           phase = false;
        }); // closing onclick
      }
      // END OF SIDEBAR
      
    }

   
    let box = new Box();
    let ctr = box.RETURN_CONTAINER();
    container.appendChild(ctr);
    container.style.padding = "0px";
    
    ctr.style.margin = "0px";
    
    console.log(window.innerWidth);
    box.RESIZE(window.innerWidth*0.95, window.innerWidth*0.95);
    
    let phase;



    let index = Math.floor(Math.random()*features.length);
    let obj = features[index];
    
    let name = (Math.random() > 0.5 ? "Khartoum" : "Grand Ethiopian Renaissance Dam");
    console.log(name);
    obj = features.filter(f => f["properties"]["NAME"] === name)[0];
    
    box.CLEAR_CANVAS();
    
    let parents = obj["properties"]["PARENTS"];
    let displayRange = {
      "xmin":999999,
      "xmax":-99999,
      "ymin":999999,
      "ymax":-99999
    };
    
    for (let i = 0; i < parents.length; i++) {
      let parent = parents[i];
      let parentFeature = features.filter(item => item["properties"]["NAME"] === parent)[0];
      if (parentFeature.xDisplayRangeMax > displayRange.xmax) {displayRange.xmax = parentFeature.xDisplayRangeMax;}
      if (parentFeature.xDisplayRangeMin < displayRange.xmin) {displayRange.xmin = parentFeature.xDisplayRangeMin;}
      if (parentFeature.yDisplayRangeMax > displayRange.ymax) {displayRange.ymax = parentFeature.yDisplayRangeMax;}
      if (parentFeature.yDisplayRangeMin < displayRange.ymin) {displayRange.ymin = parentFeature.yDisplayRangeMin;}
    }
    
    box.RANGE_X(displayRange.xmin, displayRange.xmax);
    box.RANGE_Y(displayRange.ymin, displayRange.ymax);
    
    for (let i = 0; i < parents.length; i++) {
      let parentName = parents[i];
      let parentFeature = features.filter(item => item["properties"]["NAME"] === parentName)[0];
      drawFeature(b_=box, feature_=parentFeature);
    }

    drawFeature(b_=box, feature_=obj);
    geometryNameOutputEl.innerHTML = "?";
    phase = true;
    
    ctr.addEventListener("click", function() {
      
      
      
      if (phase) {
        geometryNameOutputEl.innerHTML = obj["properties"]["NAME"];
        phase = false;
        return;
      }
      
      index = index = Math.floor(Math.random()*features.length);
      obj = features[index];

      box.CLEAR_CANVAS();

      //console.log("***");
      //console.log(obj["properties"]["NAME"]);
      let displayRange = {
        "xmin":obj.xmin,
        "xmax":obj.xmax,
        "ymin":obj.ymin,
        "ymax":obj.ymax
      };
      // console.log(displayRange);
      
      let parents = obj["properties"]["PARENTS"];
      for (let i = 0; i < parents.length; i++) {
        let parent = parents[i];
        let parentFeature = features.filter(item => item["properties"]["NAME"] === parent)[0];
        console.log(parentFeature);
        if (parentFeature.xmax > displayRange.xmax) {displayRange.xmax = parentFeature.xmax;}
        if (parentFeature.xmin < displayRange.xmin) {displayRange.xmin = parentFeature.xmin;}
        if (parentFeature.ymax > displayRange.ymax) {displayRange.ymax = parentFeature.ymax;}
        if (parentFeature.ymin < displayRange.ymin) {displayRange.ymin = parentFeature.ymin;}
      }
      
      displayRange.xspan = displayRange.xmax - displayRange.xmin;
      displayRange.yspan = displayRange.ymax - displayRange.ymin;

      displayRange.xbuffer = 0;
      displayRange.ybuffer = 0;
       
      if (displayRange.xspan > displayRange.yspan) {
        displayRange.xbuffer = displayRange.xspan*0.2;
        displayRange.ybuffer = displayRange.xspan*1.2 - displayRange.yspan;
      }
      
      if (displayRange.xspan <= displayRange.yspan) {
        displayRange.ybuffer = displayRange.yspan*0.2;
        displayRange.xbuffer = displayRange.yspan*1.2 - displayRange.xspan;
      }

      displayRange.xDisplayRangeMin = displayRange.xmin - displayRange.xbuffer/2;
      displayRange.xDisplayRangeMax = displayRange.xmax + displayRange.xbuffer/2;
      displayRange.yDisplayRangeMin = displayRange.ymin - displayRange.ybuffer/2;
      displayRange.yDisplayRangeMax = displayRange.ymax + displayRange.ybuffer/2;
      
      
      box.RANGE_X(displayRange.xDisplayRangeMin, displayRange.xDisplayRangeMax);
      box.RANGE_Y(displayRange.yDisplayRangeMin, displayRange.yDisplayRangeMax);
      
      console.log("x : " + box.data.range.x.min + " to " + box.data.range.x.max);
      
      for (let i = 0; i < parents.length; i++) {
        let parentName = parents[i];
        let parentFeature = features.filter(item => item["properties"]["NAME"] === parentName)[0];
        drawFeature(b_=box, feature_=parentFeature);
      }
      
      
      drawFeature(b_=box, feature_=obj);
      geometryNameOutputEl.innerHTML = "?";
      phase = true;
      
    }); // closing fn
      
    
    
    
    
     /*
     ANIMATION = window.setInterval(function(){
       abc();
     }, 1000);
     */
     
     function abc(obj_) {
       
      /*
      
      let obj = obj_;
      if (obj_ == null) {
        let index = index = Math.floor(Math.random()*features.length);
        obj = features[index];
      }
      
      if (phase) {
        geometryNameOutputEl.innerHTML = obj["properties"]["NAME"];
        phase = false;
        return;
      }
      */

      console.log(obj["properties"]["NAME"].toUpperCase());

      box.CLEAR_CANVAS();

      let displayRange = {
        "xmin":obj.xmin,
        "xmax":obj.xmax,
        "ymin":obj.ymin,
        "ymax":obj.ymax
      };
      // console.log(displayRange);
      
      let parents = obj["properties"]["PARENTS"];
      console.log("n_parents : " + parents.length);
      
      for (let i = 0; i < parents.length; i++) {
        let parent = parents[i];
        let parentFeature = features.filter(item => item["properties"]["NAME"] === parent)[0];
        console.log(parentFeature);
        if (parentFeature.xmax > displayRange.xmax) {displayRange.xmax = parentFeature.xmax;}
        if (parentFeature.xmin < displayRange.xmin) {displayRange.xmin = parentFeature.xmin;}
        if (parentFeature.ymax > displayRange.ymax) {displayRange.ymax = parentFeature.ymax;}
        if (parentFeature.ymin < displayRange.ymin) {displayRange.ymin = parentFeature.ymin;}
      }
      
      displayRange.xspan = displayRange.xmax - displayRange.xmin;
      displayRange.yspan = displayRange.ymax - displayRange.ymin;
      
      displayRange.xbuffer = 0;
      displayRange.ybuffer = 0;
       
      if (displayRange.xspan > displayRange.yspan) {
        displayRange.xbuffer = displayRange.xspan*0.2;
        displayRange.ybuffer = displayRange.xspan*1.2 - displayRange.yspan;
      }
      
      if (displayRange.xspan <= displayRange.yspan) {
        displayRange.ybuffer = displayRange.yspan*0.2;
        displayRange.xbuffer = displayRange.yspan*1.2 - displayRange.xspan;
      }

      displayRange.xDisplayRangeMin = displayRange.xmin - displayRange.xbuffer/2;
      displayRange.xDisplayRangeMax = displayRange.xmax + displayRange.xbuffer/2;
      displayRange.yDisplayRangeMin = displayRange.ymin - displayRange.ybuffer/2;
      displayRange.yDisplayRangeMax = displayRange.ymax + displayRange.ybuffer/2;

      box.RANGE_X(displayRange.xDisplayRangeMin, displayRange.xDisplayRangeMax);
      box.RANGE_Y(displayRange.yDisplayRangeMin, displayRange.yDisplayRangeMax);

      for (let i = 0; i < parents.length; i++) {
        let parentName = parents[i];
        let parentFeature = features.filter(item => item["properties"]["NAME"] === parentName)[0];
        drawFeature(b_=box, feature_=parentFeature);
      }
      
      drawFeature(b_=box, feature_=obj);
      geometryNameOutputEl.innerHTML = "?";
      phase = true;
     }; // closing abc

  }); // closing then-2

  
}); // closing onload



function drawFeature(b_, feature_) {

  let zoomLevel = 2;
  
  // console.log(feature_["properties"]["NAME"] + " : " + feature_["geometry"]["type"]);

  if (feature_["geometry"]["type"] == "Point") {
    drawPoint(b_, feature_);
  }
  
  if (feature_["geometry"]["type"] == "LineString") {
    //b_.CLEAR_CANVAS();
    drawLineString(b_, feature_);
  }
  
  if (feature_["geometry"]["type"] == "Polygon") {
    //b_.CLEAR_CANVAS();
    //b_.RANGE_X(feature_.xDisplayRangeMin, feature_.xDisplayRangeMax);
    //b_.RANGE_Y(feature_.yDisplayRangeMin, feature_.yDisplayRangeMax);
    drawPolygon(b_, feature_);
  } // closing if-Polygon

  if (feature_["geometry"]["type"] == "MultiPolygon") {
    //b_.CLEAR_CANVAS();
    //b_.RANGE_X(feature_.xDisplayRangeMin, feature_.xDisplayRangeMax);
    //b_.RANGE_Y(feature_.yDisplayRangeMin, feature_.yDisplayRangeMax);
    drawMultiPolygon(b_, feature_);
  }
  
}; // closing fn

function addGeometryMinMax(feature_) {
  
  if (feature_["geometry"]["type"] == "Polygon") {
    minMaxPolygon(feature_);
  } // closing if-Polygon
  
  if (feature_["geometry"]["type"] == "MultiPolygon") {
    minMaxMultiPolygon(feature_);
  }
  
  if (feature_["geometry"]["type"] == "Point") {
    minMaxPoint(feature_);
  }

  if (feature_["geometry"]["type"] == "LineString") {
    minMaxLineString(feature_);
  }

}; // closing fn

function minMaxPolygon(feature_) {
  
  let zoomLevel = 2;

  feature_.xmin = 99999;
  feature_.xmax = -9999;
  feature_.ymin = 99999;
  feature_.ymax = -9999;
  
  let coordinates = feature_["geometry"]["coordinates"][0];

  for (let i = 0; i < coordinates.length; i++) {
    let x = mercX(lon_=coordinates[i][0], zoomx_=zoomLevel);
    let y = mercY(lat_=coordinates[i][1], zoomy_=zoomLevel);
    if (x > feature_.xmax) {feature_.xmax = x;}
    if (x < feature_.xmin) {feature_.xmin = x;}
    if (y > feature_.ymax) {feature_.ymax = y;}
    if (y < feature_.ymin) {feature_.ymin = y;}
  } // closing i-loop
  
  let xspan = feature_.xmax - feature_.xmin;
  let yspan = feature_.ymax - feature_.ymin;
  feature_.xbuffer = 0;
  feature_.ybuffer = 0;
   
  if (xspan > yspan) {
    feature_.xbuffer = xspan*0.2;
    feature_.ybuffer = xspan*1.2 - yspan;
  }
  
  if (xspan <= yspan) {
    feature_.ybuffer = yspan*0.2;
    feature_.xbuffer = yspan*1.2 - xspan;
  }
  
  feature_.xDisplayRangeMin = feature_.xmin - feature_.xbuffer;
  feature_.xDisplayRangeMax = feature_.xmax + feature_.xbuffer;
  feature_.yDisplayRangeMin = feature_.ymin - feature_.ybuffer;
  feature_.yDisplayRangeMax = feature_.ymax + feature_.ybuffer;
  
}; // closing fn


function drawPolygon(b_, feature_) {
  
  let zoomLevel = 2;
  let points = [];
  let coordinates = feature_["geometry"]["coordinates"][0];

  for (let i = 0; i < coordinates.length; i++) {
    let x = mercX(lon_=coordinates[i][0], zoomx_=zoomLevel);
    let y = mercY(lat_=coordinates[i][1], zoomy_=zoomLevel);
    points.push({
      "x":x,
      "y":y
    });
  } // closing i-loop

  b_.LINE_WIDTH(3);
  b_.FILL_STYLE("#0099ff33");
  b_.STROKE_STYLE("#0099ff33");
  b_.SHAPE(points);
  
}; // closing fn



function minMaxMultiPolygon(feature_) {
  
  let zoomLevel = 2;
  let points = [];

  feature_.xmin = 99999;
  feature_.xmax = -9999;
  feature_.ymin = 99999;
  feature_.ymax = -9999;
  
  let coordinates = feature_["geometry"]["coordinates"];

  
  for (let i = 0; i < coordinates.length; i++) {

    points[i] = [];
    for (let j = 0; j < coordinates[i][0].length; j++) {
      let x = mercX(lon_=coordinates[i][0][j][0], zoomx_=zoomLevel);
      let y = mercY(lat_=coordinates[i][0][j][1], zoomy_=zoomLevel);
      if (x > feature_.xmax) {feature_.xmax = x;}
      if (x < feature_.xmin) {feature_.xmin = x;}
      if (y > feature_.ymax) {feature_.ymax = y;}
      if (y < feature_.ymin) {feature_.ymin = y;}
      points[i].push({
        "x":x,
        "y":y
      });
    } // closing j-loop
  } // closing i-loop
  
  // console.log(points);
  
  let xspan = feature_.xmax - feature_.xmin;
  let yspan = feature_.ymax - feature_.ymin;
  feature_.xbuffer = 0;
  feature_.ybuffer = 0;
   
  if (xspan > yspan) {
    feature_.xbuffer = xspan*0.2;
    feature_.ybuffer = xspan*1.2 - yspan;
  }
  
  if (xspan <= yspan) {
    feature_.ybuffer = yspan*0.2;
    feature_.xbuffer = yspan*1.2 - xspan;
  }
  
  feature_.xDisplayRangeMin = feature_.xmin - feature_.xbuffer;
  feature_.xDisplayRangeMax = feature_.xmax + feature_.xbuffer;
  feature_.yDisplayRangeMin = feature_.ymin - feature_.ybuffer;
  feature_.yDisplayRangeMax = feature_.ymax + feature_.ybuffer;

  return;
    
}; // closing fn

function drawMultiPolygon(b_, feature_) {
  
  let zoomLevel = 2;
  let points = [];

  let xmin = 99999;
  let xmax = -9999;
  let ymin = 99999;
  let ymax = -9999;
  
  let coordinates = feature_["geometry"]["coordinates"];

  for (let i = 0; i < coordinates.length; i++) {

    points[i] = [];
    for (let j = 0; j < coordinates[i][0].length; j++) {
      let x = mercX(lon_=coordinates[i][0][j][0], zoomx_=zoomLevel);
      let y = mercY(lat_=coordinates[i][0][j][1], zoomy_=zoomLevel);
      points[i].push({
        "x":x,
        "y":y
      });
    } // closing j-loop
  } // closing i-loop
  
  b_.LINE_WIDTH(3);
  b_.FILL_STYLE("#0099ff33");
  b_.STROKE_STYLE("#0099ff33");
  for (let i = 0; i < points.length; i++) {
    b_.SHAPE(points[i]);
  }
  return;
}; // closing fn


function minMaxLineString(feature_) {
  
  let zoomLevel = 2;

  feature_.xmin = 99999;
  feature_.xmax = -9999;
  feature_.ymin = 99999;
  feature_.ymax = -9999;
  
  let coordinates = feature_["geometry"]["coordinates"];

  for (let i = 0; i < coordinates.length; i++) {
    let x = mercX(lon_=coordinates[i][0], zoomx_=zoomLevel);
    let y = mercY(lat_=coordinates[i][1], zoomy_=zoomLevel);
    if (x > feature_.xmax) {feature_.xmax = x;}
    if (x < feature_.xmin) {feature_.xmin = x;}
    if (y > feature_.ymax) {feature_.ymax = y;}
    if (y < feature_.ymin) {feature_.ymin = y;}
  } // closing i-loop
  
  // console.log(points);
  
  feature_.xspan = feature_.xmax - feature_.xmin;
  feature_.yspan = feature_.ymax - feature_.ymin;
  feature_.xbuffer = 0;
  feature_.ybuffer = 0;
   
  if (feature_.xspan > feature_.yspan) {
    feature_.xbuffer = feature_.xspan*0.2;
    feature_.ybuffer = feature_.xspan*1.2 - feature_.yspan;
  }
  
  if (feature_.xspan <= feature_.yspan) {
    feature_.ybuffer = feature_.yspan*0.2;
    feature_.xbuffer = feature_.yspan*1.2 - feature_.xspan;
  }
  
  feature_.xDisplayRangeMin = feature_.xmin - feature_.xbuffer;
  feature_.xDisplayRangeMax = feature_.xmax + feature_.xbuffer;
  feature_.yDisplayRangeMin = feature_.ymin - feature_.ybuffer;
  feature_.yDisplayRangeMax = feature_.ymax + feature_.ybuffer;

  return;
}; // closing fn

function drawLineString(b_, feature_) {
  
  let zoomLevel = 2;
  let points = [];

  let coordinates = feature_["geometry"]["coordinates"];

  for (let i = 0; i < coordinates.length; i++) {
    let x = mercX(lon_=coordinates[i][0], zoomx_=zoomLevel);
    let y = mercY(lat_=coordinates[i][1], zoomy_=zoomLevel);
    points.push({
      "x":x,
      "y":y
    });
  } // closing i-loop

  b_.LINE_WIDTH(5);
  b_.FILL_STYLE("#0066cc55");
  b_.STROKE_STYLE("#0066cc55");
  
  b_.CONNECT_VALUES(points);
  return;
}; // closing fn


function minMaxPoint(feature_) {
  let zoomLevel = 2;
  let coordinates = feature_["geometry"]["coordinates"];
  let x = mercX(lon_=coordinates[0], zoomx_=zoomLevel);
  let y = mercY(lat_=coordinates[1], zoomy_=zoomLevel);
  feature_.xmin = x;
  feature_.xmax = x;
  feature_.ymin = y;
  feature_.ymax = y;
  return;  
}; // closing fn

function drawPoint(b_, feature_) {
  
  let zoomLevel = 2;

  let coordinates = feature_["geometry"]["coordinates"];
  let x = mercX(lon_=coordinates[0], zoomx_=zoomLevel);
  let y = mercY(lat_=coordinates[1], zoomy_=zoomLevel);
  
  let point = {
    "x":x,
    "y":y
  };

  b_.LINE_WIDTH(4);
  b_.FILL_STYLE("#224477aa");
  b_.STROKE_STYLE("#0099ff33");
  b_.RADIUS(4);
  b_.POINT(point);
  
  // console.log(point);
  
  return;  
}; // closing fn

function mercX(lon_, zoomx_) {
  let lon = lon_*Math.PI/180;
  let a = (128/Math.PI) * Math.pow(2, zoomx_);
  let b = lon + Math.PI;
  return a*b;
}

function mercY(lat_, zoomy_) {
  let lat = lat_*Math.PI/180;
  let a = (128/Math.PI) * Math.pow(2, zoomy_);
  let b = Math.tan(Math.PI/4 + lat/2);
  let c = Math.PI - Math.log(b);
  return -a*c;
}

</script>